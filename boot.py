import gcimport timeimport osimport dhtimport jsonimport espimport networkfrom machine import Pin, Timerfrom settings import configsfrom umqtt.simple import MQTTClient# micropython default state needs to be high for some reasondefault_state = configs['default_state']# Pins don't go in order so to make it easier to use I map them..pin_map = {    0: 16,    1: 5,    2: 4,    3: 0,    4: 2,    5: 14,    6: 12,    7: 13,    # 8: machine.Pin(15, machine.Pin.OUT, value=0),}# Initialize the pins so we can use thempins = {    0: Pin(pin_map[0], Pin.OUT, value=default_state),    1: Pin(pin_map[1], Pin.OUT, value=default_state),    2: Pin(pin_map[2], Pin.OUT, value=default_state),    3: Pin(pin_map[3], Pin.OUT, value=default_state),    4: Pin(pin_map[4], Pin.OUT, value=default_state),    5: Pin(pin_map[5], Pin.OUT, value=default_state),    6: Pin(pin_map[6], Pin.OUT, value=default_state),    7: Pin(pin_map[7], Pin.OUT, value=default_state),    # 8: machine.Pin(15, machine.Pin.OUT, value=0),}def kill():    os.remove("settings.py")    os.remove("boot.py")# esp.osdebug(None)esp.osdebug(0)gc.enable()station = network.WLAN(network.STA_IF)# not supported on some micropython versionsif os.uname()[3][:6] != 'v1.9.1' \        and os.uname()[3][:6] != 'v1.9.2' \        and os.uname()[3][:6] != 'v1.9.3' \        and os.uname()[3][:6] != 'v1.9.4':    station.config(dhcp_hostname=configs['hostname'])ap_if = network.WLAN(network.AP_IF)ap_if.active(False)mqtt_connection = MQTTClient(client_id="esp8266-tester",                             server=configs['mqtt']['host'],                             user=configs['mqtt']['user'],                             password=configs['mqtt']['pass'])def connect_wifi():    if configs['debug']:        print("Connecting to wifi")    if station.isconnected():        return    station.active(True)    station.connect(configs['wifi']['ssid'], configs['wifi']['pass'])    while not station.isconnected():        time.sleep(1)  # Wait a sec then re-try to connect        pass    try:        mqtt_connect()  # connect to mqtt after connecting/ re-connecting to the wifi    except:        print("Already connected")    if configs['debug']:        print('network config:', station.ifconfig())def button_press(pin, time_ms=500):    if default_state:        pin.value(0)        time.sleep_ms(time_ms)        pin.value(1)        time.sleep_ms(time_ms)    else:        pin.value(1)        time.sleep_ms(time_ms)        pin.value(0)        time.sleep_ms(time_ms)def pin(topic, msg):    pin_number = topic[-2:]    selected_pin_number = int(pin_number)    working_pin = pins[selected_pin_number]    selected_working_pin = pin_map[selected_pin_number]    if configs['debug']:        print(b"Pin " + pin_number + b" was called with a message of " + msg)    if msg.lower() == b"on":        button_press(working_pin, 250)        # After button press send the off command to make sure it's updated everywhere that the switch is off now        mqtt_connection.publish(topic=topic, msg="OFF", retain=False, qos=0)    elif msg.lower() == b"temperature":        d = dht.DHT11(Pin(selected_working_pin))        temperature = -1        temperature_output = -1        retry = 0        while retry < 3:            try:                d.measure()                break            except Exception as e:                if configs['debug']:                    print(e)                retry = retry + 1                if configs['debug']:                    print(".", end="")        if retry < 3:            temperature = int(d.temperature()) * 9 / 5 + 32            temperature_output = "%3.1f" % temperature            humidity = "%3.1f" % d.humidity()            humidity = str(humidity)            if configs['debug']:                print("Humidity: %s" % humidity)            publish_text = {                "tmp": temperature_output,                "tmas": "f",                "hum": humidity,                "hmeas": "rh"            }            mqtt_connection.publish(topic=topic + b"/response", msg=json.dumps(publish_text), retain=False, qos=0)    elif msg.lower() == b"double":        button_press(working_pin, 250)        button_press(working_pin, 250)        # After button press send the off command to make sure it's updated everywhere that the switch is off now        mqtt_connection.publish(topic=topic, msg="OFF", retain=False, qos=0)    elif msg.lower() == b"off":        if default_state:            working_pin.value(1)        else:            working_pin.value(0)    elif msg.lower() == b"status":        mqtt_connection.publish(topic=topic, msg=status_timers.mqtt_status(station), retain=False, qos=0)    elif msg.lower() == b"kill":        mqtt_connection.publish(topic=topic, msg="Calling kill", retain=False, qos=0)        print("calling kill")        kill()def switch_default(topic, msg):    mqtt_connection.publish(configs['mqtt']['base_topic_status'], b"invalid topic " + topic)# Received messages from subscriptions will be delivered to this callbackdef sub_cb(topic, msg):    switcher = {        configs['mqtt']['base_topic'] + b"/input/00": pin,        configs['mqtt']['base_topic'] + b"/input/01": pin,        configs['mqtt']['base_topic'] + b"/input/02": pin,        configs['mqtt']['base_topic'] + b"/input/03": pin,        configs['mqtt']['base_topic'] + b"/input/04": pin,        configs['mqtt']['base_topic'] + b"/input/05": pin,        configs['mqtt']['base_topic'] + b"/input/06": pin,        configs['mqtt']['base_topic'] + b"/input/07": pin    }    func = switcher.get(topic, switch_default)    func(topic, msg)def mqtt_connect():    mqtt_connection.set_callback(sub_cb)    if configs['debug']:        print("Connect to mqtt")    mqtt_connection.connect()    mqtt_connection.publish(configs['mqtt']['base_topic'], b"Connected")    mqtt_connection.subscribe(configs['mqtt']['base_topic_subscribe'])    while True:        if True:            # Blocking wait for message            try:                mqtt_connection.wait_msg()            except:                try:                    mqtt_connection.disconnect()                except:                    print("already connected")                mqtt_connection.connect()                mqtt_connection.publish(configs['mqtt']['base_topic'], b"Connected")                mqtt_connection.subscribe(configs['mqtt']['base_topic_subscribe'])                print("Random error happened")        else:            # Non-blocking wait for message            mqtt_connection.check_msg()            # Then need to sleep to avoid 100% CPU usage (in a real            # app other useful actions would be performed instead)            time.sleep(1)    mqtt_connection.disconnect()connect_wifi()mqtt_connect()